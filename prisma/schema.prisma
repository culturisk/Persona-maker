// Human-Rooted Segmentation Studio Database Schema

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "mongodb"
  url      = env("MONGO_URL")
}

model User {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  email      String   @unique
  name       String?
  avatarUrl  String?  @map("avatar_url")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relationships
  sessions               Session[]
  ownedWorkspaces        Workspace[]           @relation("WorkspaceOwner")
  workspaceMemberships   WorkspaceMember[]
  createdSegments        Segment[]             @relation("SegmentCreator")
  createdPersonas        Persona[]             @relation("PersonaCreator")
  createdPositioningStrategies PositioningStrategy[] @relation("PositioningCreator")
  createdMessagingStrategies   MessagingStrategy[]   @relation("MessagingCreator")
  createdPricingStrategies     PricingStrategy[]     @relation("PricingCreator")

  @@map("users")
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id") @db.ObjectId
  expires      DateTime
  createdAt    DateTime @default(now()) @map("created_at")

  // Relationships
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Workspace {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  ownerId   String   @map("owner_id") @db.ObjectId
  createdAt DateTime @default(now()) @map("created_at")

  // Relationships
  owner    User              @relation("WorkspaceOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members  WorkspaceMember[]
  segments Segment[]

  @@map("workspaces")
}

model WorkspaceMember {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  workspaceId String @map("workspace_id") @db.ObjectId
  userId      String @map("user_id") @db.ObjectId
  role        String @default("member") // member, admin

  // Relationships
  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId])
  @@map("workspace_members")
}

model Segment {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  workspaceId   String   @map("workspace_id") @db.ObjectId
  name          String
  frame         String?
  product       String?
  primaryBenefit String? @map("primary_benefit")
  reason        String?
  context       String?
  cultureAxes   Json?    @map("culture_axes") // communal↔individual, certainty↔exploration, etc.
  values        Json?
  emotions      Json?
  fears         Json?
  languageGuardrails Json? @map("language_guardrails") // do_not_say / say_instead
  evidence      String?
  notes         String?
  createdBy     String   @map("created_by") @db.ObjectId
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relationships
  workspace       Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  creator         User            @relation("SegmentCreator", fields: [createdBy], references: [id])
  cultureProfile  CultureProfile?
  economicProfile EconomicProfile?
  personas        Persona[]

  @@map("segments")
}

model CultureProfile {
  id                 String   @id @default(auto()) @map("_id") @db.ObjectId
  segmentId          String   @unique @map("segment_id") @db.ObjectId
  locale             String?  // e.g., en-IN, hi-IN, mr-IN
  languages          Json?    // [{code:"mr", script:"Deva", proficiency:"primary"}, ...]
  region             Json?    // {country:"IN", state:"MH", city:"Pune", city_tier:"Tier-1|2|3"}
  urbanicity         String?  // urban | semi-urban | rural
  communicationStyle String?  @map("communication_style") // high-context | low-context
  timeOrientation    String?  @map("time_orientation") // monochronic | polychronic
  formalityNorm      String?  @map("formality_norm") // formal | casual | mixed
  workweek           Json?    // {start:"Mon", end:"Fri", weekend:["Sat","Sun"]}
  schedulingNorms    Json?    @map("scheduling_norms") // {late_evening_ok:true, ...}
  festivals          Json?    // neutral labels only
  purchasingConstraints Json? @map("purchasing_constraints") // {cod_prevalence:true, low_bandwidth:true}
  deviceChannelPrefs Json?   @map("device_channel_prefs") // {android_share_high:true, whatsapp_preferred:true}
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  // Relationships
  segment  Segment   @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  personas Persona[]

  @@map("culture_profiles")
}

model EconomicProfile {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  segmentId                 String   @unique @map("segment_id") @db.ObjectId
  incomeBracket             String?  @map("income_bracket") // e.g., "<₹25k", "₹25k–₹50k", "₹50k–₹1L", "₹1L–₹2L", "₹2L+"
  currency                  String?  @default("INR") // ISO 4217 (INR, USD, etc.)
  profession                String?  // student, junior staff, team lead, manager, CXO, gig/freelancer, self-employed, SME owner
  industry                  String?  // IT/ITeS, retail, logistics, healthcare, edu, etc.
  yearsOfService            Int?     @map("years_of_service") // total experience
  employmentType            String?  @map("employment_type") // full-time | part-time | gig | self-employed
  financialBackground       String?  @map("financial_background") // first-gen earner, middle-class stable, entrepreneurial/volatile
  familyFinancialBackground String?  @map("family_financial_background") // dependent parents, dual-income household, caretaker responsibilities
  socioeconomicStatus       String?  @map("socioeconomic_status") // LOW | LOWER-MID | MID | UPPER-MID | HIGH
  priceSensitivity          String?  @map("price_sensitivity") // very-high | high | medium | low
  purchaseFrequency         String?  @map("purchase_frequency") // rare | occasional | regular | habitual
  paymentBehaviour          Json?    @map("payment_behaviour") // {prefers_cod:true, upi:true, emi:true, subscription_aversion:true}
  savingsInclination        String?  @map("savings_inclination") // saver | balanced | spender
  riskAppetite              String?  @map("risk_appetite") // low | moderate | high
  creditAccess              String?  @map("credit_access") // none | limited | moderate | strong
  financialGoals            Json?    @map("financial_goals") // ["education", "home", "vehicle", "travel", "emergency_fund"]
  constraints               Json?    // {shared_device:true, limited_data:true, time_poor:true}
  createdAt                 DateTime @default(now()) @map("created_at")
  updatedAt                 DateTime @updatedAt @map("updated_at")

  // Relationships
  segment  Segment   @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  personas Persona[]

  @@map("economic_profiles")
}

model Persona {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  segmentId         String   @map("segment_id") @db.ObjectId
  cultureProfileId  String?  @map("culture_profile_id") @db.ObjectId
  economicProfileId String?  @map("economic_profile_id") @db.ObjectId
  name              String
  positioning       String?
  culturalCues      Json?    @map("cultural_cues") // tone, examples, timings, channels
  economicCues      Json?    @map("economic_cues") // value framing, pricing/plan hints, payment terms, proof types
  generalizations   Json?    // testable hypotheses only
  pillars           Json?    // messaging pillars
  exportSnapshot    Json?    @map("export_snapshot")
  createdBy         String   @map("created_by") @db.ObjectId
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relationships
  segment              Segment               @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  cultureProfile       CultureProfile?       @relation(fields: [cultureProfileId], references: [id])
  economicProfile      EconomicProfile?      @relation(fields: [economicProfileId], references: [id])
  creator              User                  @relation("PersonaCreator", fields: [createdBy], references: [id])
  positioningStrategies PositioningStrategy[]
  messagingStrategies   MessagingStrategy[]
  pricingStrategies     PricingStrategy[]

  @@map("personas")
}

model PositioningStrategy {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  personaId            String   @map("persona_id") @db.ObjectId
  version              Int      @default(1)
  status               String   @default("draft") // draft | published
  positioningStatement String?  @map("positioning_statement")
  competitiveFrame     String?  @map("competitive_frame")
  categoryEntryPoints  Json?    @map("category_entry_points")
  reasonsToBelieve     Json?    @map("reasons_to_believe")
  antiPositioning      Json?    @map("anti_positioning")
  elevatorPitch1s      String?  @map("elevator_pitch_1s")
  elevatorPitch10s     String?  @map("elevator_pitch_10s")
  elevatorPitch30s     String?  @map("elevator_pitch_30s")
  inputs               Json?    // Original inputs used for generation
  assumptionsVsFacts   Json?    @map("assumptions_vs_facts")
  createdBy            String   @map("created_by") @db.ObjectId
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  // Relationships
  persona Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)
  creator User    @relation("PositioningCreator", fields: [createdBy], references: [id])

  @@unique([personaId, version])
  @@map("positioning_strategies")
}

model MessagingStrategy {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  personaId            String   @map("persona_id") @db.ObjectId
  version              Int      @default(1)
  status               String   @default("draft") // draft | published
  messagingPillars     Json?    @map("messaging_pillars") // 3-4 pillars with titles and messages
  toneOfVoice          Json?    @map("tone_of_voice") // Based on communication style
  objections           Json?    // Common objections and counter-responses
  channelPlan          Json?    @map("channel_plan") // Channel-specific messaging
  contentThemes        Json?    @map("content_themes") // Content ideas and themes
  contentCalendar      Json?    @map("content_calendar") // Calendar suggestions
  localizationOptions  Json?    @map("localization_options") // Language/regional adaptations
  assetTemplates       Json?    @map("asset_templates") // Template suggestions
  inputs               Json?    // Original inputs used for generation
  assumptionsVsFacts   Json?    @map("assumptions_vs_facts")
  createdBy            String   @map("created_by") @db.ObjectId
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  // Relationships
  persona Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)
  creator User    @relation("MessagingCreator", fields: [createdBy], references: [id])

  @@unique([personaId, version])
  @@map("messaging_strategies")
}

model PricingStrategy {
  id                     String   @id @default(auto()) @map("_id") @db.ObjectId
  personaId              String   @map("persona_id") @db.ObjectId
  version                Int      @default(1)
  status                 String   @default("draft") // draft | published
  pricingTiers           Json?    @map("pricing_tiers") // 2-4 tiers with features and prices
  paymentOptions         Json?    @map("payment_options") // EMI, UPI, bundles based on behavior
  monetizationHypotheses Json?    @map("monetization_hypotheses") // Testing hypotheses
  valueMetrics           Json?    @map("value_metrics") // How to measure and communicate value
  competitivePricing     Json?    @map("competitive_pricing") // Positioning against competitors
  discountStrategy       Json?    @map("discount_strategy") // When and how to discount
  inputs                 Json?    // Original inputs used for generation
  assumptionsVsFacts     Json?    @map("assumptions_vs_facts")
  createdBy              String   @map("created_by") @db.ObjectId
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  // Relationships
  persona Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)
  creator User    @relation("PricingCreator", fields: [createdBy], references: [id])

  @@unique([personaId, version])
  @@map("pricing_strategies")
}

model AuditLog {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String?  @map("user_id") @db.ObjectId
  action    String
  resource  String
  resourceId String? @map("resource_id")
  details   Json?
  createdAt DateTime @default(now()) @map("created_at")

  @@map("audit_logs")
}
